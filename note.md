# Networking

## Problem

为网卡编写xv6设备驱动程序，主要是`e1000_transmit()`和`e1000_recv()`，用于发送和接收数据包

## Solution

基本是按照给的Hint写。

xv6对网卡的发送和接收各维护两个循环队列：描述符队列`ring`和缓冲区指针队列`mbufs`，缓冲区队列依附于描述符队列。

寄存器组`regs`记录队列的首尾指针，通过`E1000_TDT`等索引访问。

锁`e1000_lock`，可能有多个进程同时从网卡发送数据，但是接收数据只会被中断`e1000_intr()`调用

## Implementation

1. `e1000_transmit()`
   1. 首先加锁
   2. 从寄存器获取尾指针的值，即缓冲区可以写入的位置
   3. 判断队列是否已满
      1. 通过描述符的`E1000_TXD_STAT_DD`标志位判断
      2. 设置这个标志位的描述符已经被网卡硬件处理完了（即发送）
   4. 如果缓冲区没有被释放的话释放缓冲区
   5. 把传入的`mbuf`更新到缓冲区中
      1. 更新描述符的地址和长度
      2. 更新`cmd`字段为`E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS`
         1. 第一个是数据包的结束，第二个是使`status`字段有效
         2. 其实只给出了这两个标志的定义
      3. 标记`status`为0（没处理完）
   6. 更新尾指针
2. `e1000_recv()`
   1. 从寄存器获取尾指针的值
      1. 这里要+1，因为尾指针指的是已经被处理完的数据
   2. 判断数据包是否可用
      1. 依旧是`DD`位，表示已经被网卡硬件处理完毕，可以被内核处理
   3. 进入处理循环
      1. 每次都应判断对应索引的包是否可用
      2. 因为尾指针+1以后会有多个数据
   4. 把描述符中的长度更新到缓冲区，然后调用`net_rx()`读取
   5. 调用`mbufalloc()`新申请一块内存，覆盖之前缓冲区的内容
   6. 更新描述符的地址和状态
   7. 更新寄存器尾指针的值
   8. 更新索引(+1)